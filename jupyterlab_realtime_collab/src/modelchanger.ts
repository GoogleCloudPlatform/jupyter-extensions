import { INotebookModel, NotebookPanel } from '@jupyterlab/notebook';
import { INotebookContent, IBaseCell, MultilineString } from '@jupyterlab/nbformat';
import { DocumentRegistry } from '@jupyterlab/docregistry';
import { IModelDB, IObservableList } from '@jupyterlab/observables';
import { ICellModel } from '@jupyterlab/cells';


// ICollabNotebookContent is a simple interface extension that is only used for 
// communication with the collaborative editing backend.
export interface ICollabNotebookContent extends INotebookContent {
  cells: ICellWithID[];
}

// ICellWithID adds ids to cells and is only used in the collaborative editing backend.
// The ids themselves are generated by the Notebook extension; however, converting to and from JSON
// does not normally include these generated ids, so we add them in here for consistency when syncing
// notebooks.
export interface ICellWithID extends IBaseCell {
  id: string;
}

// ModelChanger handles changing the underlying Notebook's model, which represents the data/text of
// the notebook. It specifically handles the application of remote ops to the local files; local
// ops to the remote are handled by notebookListener.
export class ModelChanger {
  private guaranteedPath = 'value'; // all cells should have this value if they exist in the db.
  private nbContext: DocumentRegistry.IContext<INotebookModel>;

  constructor(panel: NotebookPanel) {
    this.nbContext = panel.context;
  }

  // Convenience accessors so we don't have to type everything out every time.
  get db(): IModelDB {
    return this.nbContext.model.modelDB;
  }

  get model(): INotebookModel {
    return this.nbContext.model;
  }

  get cells(): IObservableList<ICellModel> {
    return this.model.cells;
  }

  // updateModel 
  updateModel(file: ICollabNotebookContent): Array<ICellModel> {
    const added = new Array<ICellModel>();
    for(let i=0; i<file.cells.length; i++) {
      if (this._hasCell(file.cells[i])) {
        this._modifyCell(file.cells[i], i);
      } else {
        const newCell = this._insertCell(file.cells[i], i);
        added.push(newCell);
      }
    }
    // everything that is in the cell list that is at or past file.cells.length needs to
    // be deleted.
    this.cells.removeRange(file.cells.length, this.cells.length-1);
    return added;
  }

  private _hasCell(cell: ICellWithID): boolean {
    const check = this._fullCellPath(cell.id, this.guaranteedPath);
    return this.db.has(check);
  }

  private _fullCellPath(id: string, path: string) {
    return `cells.${id}.${path}`;
  }

  private _insertCell(cell: ICellWithID, pos: number): ICellModel {
    let cellModel: ICellModel;
    
    const options = {
      id: cell.id,
      cell: cell
    };
    switch(cell.cell_type) {
      case 'code':
        cellModel = this.model.contentFactory.createCodeCell(options);
        break;
      case 'raw':
        cellModel = this.model.contentFactory.createRawCell(options);
        break;
      case 'markdown':
        cellModel = this.model.contentFactory.createMarkdownCell(options);
        break;
      default:
        console.log('Cell with missing cell type, could not insert:');
        console.log(cell);
        return null;
    }
    this.cells.insert(pos, cellModel);
    return cellModel;
  }

  private _modifyCell(cell: ICellWithID, expectedPos: number) {
    // handles both changing the value of a cell and changing its position if needed.
    const cellAtPos = this.model.cells.get(expectedPos);
    if (cellAtPos.id != cell.id) {
      // We are assuming that this._hasCell has been called and returned true;
      // Therefore the actual cell is somewhere in the list and we need to swap it into the correct position.
      const actualCellPos = this.cellPosWithID(cell.id);
      this.cells.move(actualCellPos, expectedPos);
    }
    // normally changing the cell's type will create a new cell with the same model but different type and id,
    // but we override that behavior here to preserve id's on cell type change. As a result we can differentiate
    // modified and inserted cells.
    if (cell.cell_type != cellAtPos.type) {
      this._changeCellType(this.cells.get(expectedPos), cellAtPos.type, expectedPos);
    } else {
      // The process of changing cell type already inserts the new value for the cell's text
      // because of convenience.
      this._setValue(cell.source, expectedPos);
    }
  }

  private _setValue(value: MultilineString, pos: number) {
    // TODO(itsazhuhere@): try insert and deleting instead of replacing the entire string.
    this.cells.get(pos).value.text = this._coerceString(value);
  }

  private _changeCellType(cell: ICellModel, oldType: string, pos: number) {
    // Does operations similar to NotebookActions.changeCellType; however, this version does not
    // require cells to already be selected, and it preserves the cell id.
    const cellJSON = cell.toJSON();
    let newCell: ICellModel;
    switch (cell.type) {
        case 'code':
            newCell = this.model.contentFactory.createCodeCell({ 
              cell: cellJSON,
              id: cell.id
            });
            break;
        case 'markdown':
            newCell = this.model.contentFactory.createMarkdownCell({ 
              cell: cellJSON,
              id: cell.id
            });
            if (oldType === 'code') {
                newCell.trusted = false;
            }
            break;
        default:
            newCell = this.model.contentFactory.createRawCell({ 
              cell: cellJSON,
              id: cell.id
            });
            if (oldType === 'code') {
                newCell.trusted = false;
            }
    }
    this.cells.set(pos, newCell);
  }

  cellPosWithID(id: string): number {
    // TODO(itsahuhere@): improve to constant time instead of linear complexity
    for (let i = 0; i < this.cells.length; i++) {
      if (this.cells.get(i).id == id) return i;
    }
    console.log(`_cellPosWithID reached end of cell list for id ${id}`);
    return -1;
  }

  private _coerceString(source: MultilineString): string {
    if (Array.isArray(source)) {
      return source.join('');
    } else {
      return source;
    }
  }
}